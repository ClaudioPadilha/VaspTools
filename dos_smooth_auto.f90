subroutine smooth (sigma, dos, ndiv, dos_s)
  implicit none

  integer, intent (in)                                :: ndiv
  real, intent (in)                                   :: sigma
  real, dimension (:, :), intent (in)                 :: dos
  real, dimension (:, :), allocatable, intent (out)   :: dos_s

  integer                                             :: i, j, k, n, m, p, q
  double precision                                    :: dE, Ei, Ef, dif = 1.0d0 
  integer, parameter                                  :: pi = 3.14159265

  n = size (dos, 1)
  m = size (dos, 2)
  p = ndiv * (m - 1)

  allocate (dos_s (n, p)) 
  
  dos_s = 0.0d0
  Ei = dos (1, 1)
  Ef = dos (1, m)

  dE = (Ef - Ei) / p
 
  do i = 1, p + 1
    dos_s (1, i) = Ei + (i - 1) * dE 
    if (abs (dos_s (1, i) - dos_s (1, 1) - 3 * sigma) .lt. dif) then
       q = i
       dif = abs (dos_s (1, i) - dos_s (1, 1) - 3 * sigma)
    end if
  end do

  do i = 2, n
    do j = 1, m
      if ((j - 1) * ndiv - q .lt. 1) then
        do k = 1, (j - 1) * ndiv + q
          dos_s (i, k) = dos_s (i, k) + dos (i, j) * exp (- 0.5 * ((dos_s (1, k) - dos (1, j)) / sigma) ** 2)
        end do
      else if ((j - 1) * ndiv + q .gt. p) then
        do k = (j - 1) * ndiv - q, p 
          dos_s (i, k) = dos_s (i, k) + dos (i, j) * exp (- 0.5 * ((dos_s (1, k) - dos (1, j)) / sigma) ** 2)
        end do
      else
        do k = (j - 1) * ndiv - q, (j - 1) * ndiv + q 
          dos_s (i, k) = dos_s (i, k) + dos (i, j) * exp (- 0.5 * ((dos_s (1, k) - dos (1, j)) / sigma) ** 2)
        end do
      end if 
    end do   
  end do
  
end subroutine smooth

function col_count (u)
  implicit none

  integer         :: n, i, j = 0, col_count, u
  character(380)  :: line
  logical         :: c

  !open (u, FILE = entrada, STATUS = 'OLD')

  read (u, '(A)') line

  do i = 1, len (line)
    if (line (i:i) /= ' ') then
      c = .true.
    else
      c = .false.
    end if

    if (c .and. line (i + 1 : i + 1) == ' ') then
      j = j + 1
    end if
  end do

  rewind (u)

  col_count = j

end function col_count

function row_count (u, n)
  implicit none

  integer   :: n, u, row_count, i, stat = 0, j = 0
  real      :: temp

  do
    read (u, *, IOSTAT = stat) (temp, i = 1, n)
    if (stat /= 0) exit
    j = j + 1
  end do

  rewind (u)

  row_count = j

end function row_count

module suporte 
  interface ajusta 
    subroutine smooth (sigma, dos, ndiv, dos_s)
      implicit none

      integer, intent (in)                                :: ndiv
      real, intent (in)                                   :: sigma
      real, dimension (:, :), intent (in)                 :: dos
      real, dimension (:, :), allocatable, intent (out)   :: dos_s   
    end subroutine smooth
  end interface ajusta 

  interface conta
    function col_count (u)
      implicit none

      integer         :: n, i, j = 0, col_count, u
      character(380)  :: line
      logical         :: c
    end function col_count

    function row_count (u, n)
      implicit none

      integer   :: n, u, row_count, i, stat = 0, j = 0
      real      :: temp
    end function row_count
  end interface conta
end module suporte

program SmoothDensityOfStates
  use suporte
 
  implicit none

  integer                                        :: n, m, i, j, k, l, u = 97, v = 98, ndiv, stat = 0, p
  real, dimension (:, :), allocatable            :: dos, dos_s
  real                                           :: sigma, tempr
  character (len=450)                            :: entrada, saida
  character (len=20)                             :: temp, tempp, tempq

  call get_command_argument (1, entrada)
  call get_command_argument (2, tempp)
  call get_command_argument (3, tempq)

  if (len_trim (tempq) .eq. 0) then
    print *, ' '
    print *, 'Error: '
    print *, ' '
    print *, 'Sintax: dos_smooth.x [input file] [N] [sigma]'
    print *, ' '
    print *, 'N = multiplicatio factor of the mesh:'
    print *, '  The DOS is a n-entries vector. The smooth DOS will be a (N * n)-entries vector'
    print *, ' '
    print *, 'sigma = dispersion'
    print *, '  half-width broadening of the fitted gaussians at each point'
    print *, ' '
    print *, 'the input file should be a *-DOS-total or *-DOS-proj-* file generated by the dos_vasp.x program'
    print *, ' '
    stop
  end if
  
  read (tempp, '(I3)') ndiv
  read (tempq, '(F5.2)') sigma

! Open the data file
  open (u, FILE = entrada, STATUS = 'OLD')

  p = col_count (u)

  n = row_count (u, p)
  
  allocate (dos (p, n))

  rewind (u)

  do i = 1, n
    read (u, *) (dos (k, i), k = 1, p)
  end do

  saida = trim(entrada) // '-smooth'

  call smooth (sigma, dos, ndiv, dos_s)

  m = size (dos_s, 2)

  open (v, FILE = saida, STATUS = 'replace')

  do i = 1, m 
    write (v, *) (dos_s (k, i), k = 1, p) 
  end do

  close (v)

end program SmoothDensityOfStates
